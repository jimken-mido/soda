"use strict";(globalThis.webpackChunkPhoenix_docs=globalThis.webpackChunkPhoenix_docs||[]).push([[28856],{11333:(e,t,a)=>{a.d(t,{A:()=>n});const n=a.p+"assets/files/dates-example-2f9d5521f6e71d7b21d3c2102219b6f5.csv"},15680:(e,t,a)=>{a.d(t,{xA:()=>m,yg:()=>c});var n=a(96540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter(function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable})),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach(function(t){r(e,t,a[t])}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach(function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))})}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),d=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=d(e.components);return n.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},g=n.forwardRef(function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),u=d(a),g=r,c=u["".concat(s,".").concat(g)]||u[g]||p[g]||i;return a?n.createElement(c,o(o({ref:t},m),{},{components:a})):n.createElement(c,o({ref:t},m))});function c(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=g;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:r,o[1]=l;for(var d=2;d<i;d++)o[d]=a[d];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}g.displayName="MDXCreateElement"},67107:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(58168),r=(a(96540),a(15680));const i={title:"Wrangling Dates with SCL",description:"Use the Phoenix Configuration Language to easily combine and convert dates when working with structured data formats.",slug:"wrangling-dates-with-scl",date:"2022/04/04",authors:[{name:"Mark Wainwright",title:"Phoenix Maintainer",url:"https://github.com/wainwrightmark",image_url:"https://avatars.githubusercontent.com/u/5428904?s=400&u=272a94528302c122cfe8964069c86b65dd406645&v=4"}],tags:["Phoenix","scl","examples","dates","structured data","transform","schemas"]},o="Wrangling Dates with SCL",l={permalink:"/soda/blog/wrangling-dates-with-scl",editUrl:"https://github.com/jimken-mido/soda/blog/20220404-wrangling-dates/wrangling-dates.md",source:"@site/blog/20220404-wrangling-dates/wrangling-dates.md",title:"Wrangling Dates with SCL",description:"Use the Phoenix Configuration Language to easily combine and convert dates when working with structured data formats.",date:"2022-04-04T00:00:00.000Z",formattedDate:"April 4, 2022",tags:[{label:"Phoenix",permalink:"/soda/blog/tags/phoenix"},{label:"scl",permalink:"/soda/blog/tags/scl"},{label:"examples",permalink:"/soda/blog/tags/examples"},{label:"dates",permalink:"/soda/blog/tags/dates"},{label:"structured data",permalink:"/soda/blog/tags/structured-data"},{label:"transform",permalink:"/soda/blog/tags/transform"},{label:"schemas",permalink:"/soda/blog/tags/schemas"}],readingTime:6.095,hasTruncateMarker:!0,authors:[{name:"Mark Wainwright",title:"Phoenix Maintainer",url:"https://github.com/wainwrightmark",image_url:"https://avatars.githubusercontent.com/u/5428904?s=400&u=272a94528302c122cfe8964069c86b65dd406645&v=4",imageURL:"https://avatars.githubusercontent.com/u/5428904?s=400&u=272a94528302c122cfe8964069c86b65dd406645&v=4"}],frontMatter:{title:"Wrangling Dates with SCL",description:"Use the Phoenix Configuration Language to easily combine and convert dates when working with structured data formats.",slug:"wrangling-dates-with-scl",date:"2022/04/04",authors:[{name:"Mark Wainwright",title:"Phoenix Maintainer",url:"https://github.com/wainwrightmark",image_url:"https://avatars.githubusercontent.com/u/5428904?s=400&u=272a94528302c122cfe8964069c86b65dd406645&v=4",imageURL:"https://avatars.githubusercontent.com/u/5428904?s=400&u=272a94528302c122cfe8964069c86b65dd406645&v=4"}],tags:["Phoenix","scl","examples","dates","structured data","transform","schemas"]},prevItem:{title:"Performance Improvements in v0.18.0",permalink:"/soda/blog/performance-improvements-in-v0.18.0"}},s={authorsImageUrls:[void 0]},d=[{value:"Sample Data",id:"sample-data",level:2},{value:"Reading the Data",id:"reading-the-data",level:2},{value:"Combining the Date Fields",id:"combining-the-date-fields",level:2},{value:"The Schema",id:"the-schema",level:2},{value:"The Date Formats",id:"the-date-formats",level:2},{value:"The Transform Step",id:"the-transform-step",level:2},{value:"Exporting the Results",id:"exporting-the-results",level:2},{value:"Final Output",id:"final-output",level:2},{value:"Final SCL",id:"final-scl",level:2},{value:"Try on the Playground",id:"try-on-the-playground",level:2}],m={toc:d},u="wrapper";function p({components:e,...t}){return(0,r.yg)(u,(0,n.A)({},m,t,{components:e,mdxType:"MDXLayout"}),(0,r.yg)("p",null,"You have a structured data file you need to process.\nI'll use CSV here but it could be any data format that SCL supports.\nIt has all the information you need but the date fields are spread\nout across multiple columns and several different date formats are used."),(0,r.yg)("p",null,"In this blog post I'll show how to use SCL to combine all the date\nfields into one and how to handle multiple formats"),(0,r.yg)("h2",{id:"sample-data"},"Sample Data"),(0,r.yg)("p",null,"The following is the CSV file I'll be using in this example."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-text"},'"Date","Time","TimeZone","Location"\n"January, 01 2000","01:23:45","+00:00","UK"\n"December, 31 1999","15:23:45","-10:00","Hawaii"\n"January, 01 2000","02:23:45","+01:00","France"\n"January, 01 2000","06:53:45","+05:30","India"\n"01/01/2000","01:23:45","+00:00","Iceland"\n"31/12/1999","15:23:45","-10:00","Hawaii"\n"01/01/2000","02:23:45","+01:00","Germany"\n"01/01/2000","06:53:45","+05:30","Sri Lanka"\n')),(0,r.yg)("p",null,"It has the same date and time written in eight different ways with two different\ntime formats and four different timezones."),(0,r.yg)("p",null,"As an additional headache, the Date, Time, and Timezone data is spread across\nthree different fields."),(0,r.yg)("p",null,"Download the example file ",(0,r.yg)("a",{target:"_blank",href:a(11333).A},"here"),". Or just copy the example above."),(0,r.yg)("h2",{id:"reading-the-data"},"Reading the Data"),(0,r.yg)("p",null,"To read the data, make sure you have the ",(0,r.yg)("a",{parentName:"p",href:"/docs/connectors/filesystem"},"File System"),"\nand ",(0,r.yg)("a",{parentName:"p",href:"/docs/connectors/structureddata"},"Structured Data")," connectors configured,\nthen run:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"- <data> = FileRead 'dates-example.csv' | FromCSV\n")),(0,r.yg)("p",null,"This reads the contents of the file and pipes the resulting stream into the ",(0,r.yg)("inlineCode",{parentName:"p"},"FromCSV")," step\nwhich converts it into ",(0,r.yg)("a",{parentName:"p",href:"/docs/entities"},"entities"),"."),(0,r.yg)("p",null,"The rest of this process works with any data source, not just CSV."),(0,r.yg)("h2",{id:"combining-the-date-fields"},"Combining the Date Fields"),(0,r.yg)("p",null,"To parse the dates correctly, we need to combine the three fields.\nWe can use ",(0,r.yg)("inlineCode",{parentName:"p"},"ArrayMap")," to add another field which is the concatenation of all three."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"- <newdata> = <data>\n| ArrayMap (In <> Set: 'FullDate' To: $\"{<>['Time']} {<>['Date']} {<>['TimeZone']}\")\n")),(0,r.yg)("p",null,"Here we use ",(0,r.yg)("inlineCode",{parentName:"p"},"ArrayMap")," which maps every entity in our array (",(0,r.yg)("inlineCode",{parentName:"p"},"FromCSV")," produces\nan Array of Entities) to a new value."),(0,r.yg)("p",null,"Here the new value is the same entity but with an additional 'FullDate' field added\nwhich is the values of the three other fields concatenated together using an\n",(0,r.yg)("a",{parentName:"p",href:"/steps/Core/StringInterpolate"},"interpolated string"),"."),(0,r.yg)("h2",{id:"the-schema"},"The Schema"),(0,r.yg)("p",null,"In order to convert this date string to an actual date we need to create a\n",(0,r.yg)("a",{parentName:"p",href:"/docs/schemas"},"schema")," to tell the ",(0,r.yg)("inlineCode",{parentName:"p"},"Transform")," step what the\ndata is supposed to look like."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"- <schema> = (\n    'type': 'object'\n    'additionalProperties': false\n    'properties': (\n      'Location': ('type': 'string')\n      'FullDate': ('type': 'string', 'format': 'date-time')\n    )\n    'required': ['FullDate', 'Location']\n  )\n")),(0,r.yg)("p",null,"To explain the schema:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'type': 'object'")," tells the ",(0,r.yg)("inlineCode",{parentName:"li"},"Transform")," step to expect an entity."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'additionalProperties': False")," will remove all the properties which are not listed in\nthe schema. This is how we get rid of the now redundant 'Date', 'Time', and 'TimeZone' fields."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'properties':")," is the list of properties to expect and their types."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'Location': ('type': 'string')")," the location field is just a plain string."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'FullDate': ('type': 'string', 'format':'date-time')")," The date field is also a string but the\n",(0,r.yg)("inlineCode",{parentName:"li"},"'format':'date-time'")," tells the ",(0,r.yg)("inlineCode",{parentName:"li"},"Transform")," step to convert it into a DateTime."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"'required': ['Date', 'Location' ]")," tells the ",(0,r.yg)("inlineCode",{parentName:"li"},"Transform")," step to give an error or warning\nif any of these fields are missing")),(0,r.yg)("h2",{id:"the-date-formats"},"The Date Formats"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"- <dateFormats> = ['HH:mm:ss MMMM, dd yyyy zzz', 'HH:mm:ss dd/MM/yyyy zzz']\n")),(0,r.yg)("p",null,"For the ",(0,r.yg)("inlineCode",{parentName:"p"},"Transform")," step to correctly parse the dates, we need to tell it what date formats to expect.\nIn this case we give it an array with the two different formats present in the data.\nIt will try the first one first, then the second, and if that is unsucessful it will give you an error message."),(0,r.yg)("p",null,"If we had just one date format we could give just that string rather than an array with one element."),(0,r.yg)("p",null,"If we had several full date columns with a different format per column we could give an entity\nmapping column names to formats but that is not required in this case."),(0,r.yg)("p",null,"SCL is run inside C# and uses the C# Date parsing features and format specifiers.\nSee ",(0,r.yg)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings"},"this document"),"\nwhich explains how those work and how to use them but briefly:"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"HH:mm:ss")," means hours, minutes, and seconds separated by colons"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"MMMM")," is the full word name for the month while 'MM' is the two digit representation"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"dd")," and ",(0,r.yg)("inlineCode",{parentName:"li"},"yyyy")," are day number and year respectively"),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"zzz")," is the timezone hours and minutes offset from UTC. The timezone specifiers can\nbe quite fiddly and you may have to use multiple formats to get it right (e.g. if the\ntimezone is omitted or just '0' for UTC but another format everywhere else)")),(0,r.yg)("h2",{id:"the-transform-step"},"The Transform Step"),(0,r.yg)("p",null,"Now that we have our data, our schema, and our date formats we can run the ",(0,r.yg)("inlineCode",{parentName:"p"},"Transform")," step."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"<result> = <newdata> | Transform Schema: <schema> DateInputFormats: <dateFormats>\n")),(0,r.yg)("p",null,"The ",(0,r.yg)("inlineCode",{parentName:"p"},"Transform")," step has a lot of optional arguments but apart from ",(0,r.yg)("inlineCode",{parentName:"p"},"DateInputFormats")," the\ndefaults are good enough for us in this case."),(0,r.yg)("p",null,"We could have set"),(0,r.yg)("ul",null,(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ErrorBehavior")," to control what happens if a transformation is not possible. By default you\nget an error but you could get a warning or ignore it entirely. This also lets you control\nwhether or not to output the entity which caused the error."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"ArrayDelimiters")," lets you specify which characters can be array delimiters. This way you\ncould transform strings like 'alpha|beta|gamma' into arrays."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"BooleanTrueFormats"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"BooleanFalseFormats"),", and ",(0,r.yg)("inlineCode",{parentName:"li"},"NullFormats")," allow you to specify which\nstrings can be converted to ",(0,r.yg)("inlineCode",{parentName:"li"},"True"),", ",(0,r.yg)("inlineCode",{parentName:"li"},"False"),", and ",(0,r.yg)("inlineCode",{parentName:"li"},"Null")," respectively. As with the\n",(0,r.yg)("inlineCode",{parentName:"li"},"DateInputFormats")," you can do this on a column by column basis if needed."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"CaseSensitive")," allows you to specify whether or not the above formats are case sensitive.\nThis is false by default."),(0,r.yg)("li",{parentName:"ul"},(0,r.yg)("inlineCode",{parentName:"li"},"RoundingPrecision")," lets you control how close a floating point number needs to be to an\ninteger to be rounded to it.")),(0,r.yg)("h2",{id:"exporting-the-results"},"Exporting the Results"),(0,r.yg)("p",null,"We can output the data also as a CSV, but this time with tabs as the separator."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"<result> | ToCSV DateTimeFormat: 'yyyy-MM-dd HH:mm:ss' Delimiter: \"\\t\"\n")),(0,r.yg)("p",null,(0,r.yg)("inlineCode",{parentName:"p"},"DateTimeFormat")," lets us specify how the ",(0,r.yg)("inlineCode",{parentName:"p"},"DateTime")," is formatted in the output."),(0,r.yg)("admonition",{type:"caution"},(0,r.yg)("p",{parentName:"admonition"},"The delimiter ",(0,r.yg)("inlineCode",{parentName:"p"},"\\t")," ",(0,r.yg)("em",{parentName:"p"},"must")," be in double quotes. Single quotes are interpreted as a literal string.")),(0,r.yg)("h2",{id:"final-output"},"Final Output"),(0,r.yg)("p",null,"In the final output we see that all dates are now the same, which is correct:"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-csv"},"Location    FullDate\nUK    01:23:45 2000-01-01\nHawaii    01:23:45 2000-01-01\nFrance    01:23:45 2000-01-01\nIndia    01:23:45 2000-01-01\nIceland    01:23:45 2000-01-01\nHawaii    01:23:45 2000-01-01\nGermany    01:23:45 2000-01-01\nSri Lanka    01:23:45 2000-01-01\n")),(0,r.yg)("h2",{id:"final-scl"},"Final SCL"),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},"- <schema> = (\n    'type': 'object'\n    'additionalProperties': false\n    'properties': (\n      'Location': ('type': 'string')\n      'FullDate': ('type': 'string', 'format': 'date-time')\n    )\n    'required': ['FullDate', 'Location']\n  )\n\n- <dateFormats> = ['HH:mm:ss MMMM, dd yyyy zzz', 'HH:mm:ss dd/MM/yyyy zzz']\n\n- <data>\n| FromCSV\n| ArrayMap (In <> Set: 'FullDate' To: $\"{<>['Time']} {<>['Date']} {<>['TimeZone']}\" )\n| Transform Schema: <schema> DateInputFormats: <dateFormats>\n| ToCSV DateTimeFormat: 'yyyy-MM-dd HH:mm:ss' Delimiter: \"\\t\"\n")),(0,r.yg)("h2",{id:"try-on-the-playground"},"Try on the Playground"),(0,r.yg)("p",null,"You can try this SCL on the ",(0,r.yg)("a",{parentName:"p",href:"/playground"},"playground"),", just copy, paste, and run."),(0,r.yg)("pre",null,(0,r.yg)("code",{parentName:"pre",className:"language-scl"},'- <data> = """\n"Date","Time","TimeZone","Location"\n"January, 01 2000","01:23:45","+00:00","UK"\n"December, 31 1999","15:23:45","-10:00","Hawaii"\n"January, 01 2000","02:23:45","+01:00","France"\n"January, 01 2000","06:53:45","+05:30","India"\n"01/01/2000","01:23:45","+00:00","Iceland"\n"31/12/1999","15:23:45","-10:00","Hawaii"\n"01/01/2000","02:23:45","+01:00","Germany"\n"01/01/2000","06:53:45","+05:30","Sri Lanka"\n"""\n\n- <schema> = (\n    \'type\': \'object\'\n    \'additionalProperties\': false\n    \'properties\': (\n      \'Location\': (\'type\': \'string\')\n      \'FullDate\': (\'type\': \'string\', \'format\': \'date-time\')\n    )\n    \'required\': [\'FullDate\', \'Location\']\n  )\n\n- <dateFormats> = [\'HH:mm:ss MMMM, dd yyyy zzz\', \'HH:mm:ss dd/MM/yyyy zzz\']\n\n- <data>\n| FromCSV\n| ArrayMap (In <> Set: \'FullDate\' To: $"{<>[\'Time\']} {<>[\'Date\']} {<>[\'TimeZone\']}" )\n| Transform Schema: <schema> DateInputFormats: <dateFormats>\n| ToCSV DateTimeFormat: \'yyyy-MM-dd HH:mm:ss\' Delimiter: "\\t"\n| Print\n')))}p.isMDXComponent=!0}}]);